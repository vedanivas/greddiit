{"version":3,"sources":["../src/main.ts"],"sourcesContent":["import { Schema, Model, SchemaType } from \"mongoose\";\r\n\r\nconst messages: Record<string, any> = {\r\n  schemaTypeError: {\r\n    \"zh-CN\": '参数 \"schema\" 的类型得是 \"Schema\"。',\r\n    \"en-US\": 'param \"schema\" type must be \"Schema\".',\r\n  },\r\n  modelCountError: {\r\n    \"zh-CN\": \"钩子函数访问到的 Model 数量为 0 或者不存在。\",\r\n    \"en-US\": \"The number of models accessed is 0 or does not exist.\",\r\n  },\r\n};\r\n\r\n/**\r\n * 翻译//函数\r\n */\r\nfunction i18n(messageId: string) {\r\n  if (messageId in messages) {\r\n    const message = messages[messageId];\r\n    const lang = (process.env.LANG ?? \"\").match(\"CN\");\r\n    if (lang) return message[\"zh-CN\"];\r\n    else return message[\"en-US\"];\r\n  }\r\n}\r\n\r\nexport function MongooseFindByReference(schema: Schema) {\r\n  // 假设得到的不是 Schema 则报错\r\n  if (schema.constructor.name !== \"Schema\")\r\n    throw new Error(i18n(\"schemaTypeError\"));\r\n\r\n  // 对 Schema 挂上钩子\r\n  schema.pre([\"find\", \"findOne\"], async function (next) {\r\n    /** 当前的 Model 们 */\r\n    const models = this.model.db.models;\r\n\r\n    // 对  Models 进行判空\r\n    if (Object.keys(models ?? {}).length === 0)\r\n      throw new Error(i18n(\"modelCountError\"));\r\n\r\n    /** 当前的 Schema */\r\n    const schema: Schema = this.model.schema;\r\n\r\n    /**\r\n     * 返回 Ref Path 关联的 Model。\r\n     * Return the Model which conntected with Ref Path.\r\n     * @param obj\r\n     * @returns\r\n     */\r\n    function getModel(obj: SchemaType): Model<any> | undefined {\r\n      let refKey = \"\";\r\n      if (obj?.instance === \"ObjectID\") {\r\n        // 假设是 Ref Path 就直接读取\r\n        const options = obj.options;\r\n        if (options?.ref?.length) refKey = options.ref;\r\n        // else if (options?.refPath?.length)\r\n        //   if (schema.path(options.refPath)) return { refPath: options.refPath };\r\n      } else if ((obj as any)?.$embeddedSchemaType) {\r\n        // 假设是数组就读取子项 Type\r\n        return getModel((obj as any).$embeddedSchemaType);\r\n      }\r\n      return models[refKey];\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param paths\r\n     *\r\n     * @exmples ['owner','name','en-US']  => ['owner', 'name.en-US']\r\n     */\r\n    function transPath2RefPath(\r\n      paths: string[],\r\n      tSchema: Schema = schema\r\n    ): string[] {\r\n      let previousPath: string[] = [];\r\n      while (paths.length > 0) {\r\n        const path = paths.shift() ?? \"\";\r\n        if (tSchema.path([...previousPath, path].join(\".\"))) {\r\n          previousPath.push(path);\r\n        } else {\r\n          const currentModel = getModel(tSchema.path(previousPath.join(\".\")));\r\n          if (currentModel) {\r\n            const result = [\r\n              previousPath.join(\".\"),\r\n              ...transPath2RefPath([path, ...paths], currentModel.schema),\r\n            ];\r\n            return result;\r\n          } else return [path];\r\n        }\r\n      }\r\n      return previousPath;\r\n    }\r\n\r\n    `{\r\n        $and:{\r\n            'owner.name':'Dean',\r\n            'infos.timestamp.createdAt':Date,\r\n        },\r\n        $or:[]\r\n    }`;\r\n\r\n    async function lookup(\r\n      prevPaths: string[],\r\n      conditions: Record<string, any>,\r\n      cSchema = schema\r\n    ): Promise<any> {\r\n      // 如果 Conditions 不能进行分析就直接返回它\r\n      if (\r\n        typeof conditions !== \"object\" ||\r\n        conditions === null ||\r\n        Object.keys(conditions).length === 0\r\n      ) {\r\n        return conditions;\r\n      }\r\n\r\n      /** 最终结果 */\r\n      const result: Record<string, any> = {};\r\n\r\n      // 获取前一个 Path 的值\r\n      const prevPathsValue = cSchema.path(prevPaths.join(\".\"));\r\n\r\n      for (let [paths, value] of Object.entries(conditions)) {\r\n        // paths 1 = 'owner.name.en'; value 1 = 'Dean'\r\n\r\n        // 判断 Paths 存在于 Schema 上\r\n        if (schema.path(paths)) {\r\n        } else {\r\n          const reduceResult = [\r\n            ...transPath2RefPath(paths.split(\".\")),\r\n            value as any,\r\n          ].reduceRight((previousValue, currentValue) =>\r\n            currentValue === \"$\"\r\n              ? previousValue\r\n              : { [currentValue]: previousValue }\r\n          );\r\n          [[paths, value]] = Object.entries(reduceResult);\r\n        }\r\n\r\n        // 当前的 Paths 数组\r\n        const currentPathsArray = paths.startsWith(\"$\")\r\n          ? paths === \"$\"\r\n            ? prevPaths\r\n            : []\r\n          : [...prevPaths, paths];\r\n\r\n        // 当前的 Paths\r\n        const currentPathsString = currentPathsArray.join(\".\");\r\n\r\n        // 当前的 Paths 对应的值\r\n        const currentPathsValue = cSchema.path(currentPathsString);\r\n\r\n        if (!paths.startsWith(\"$\"))\r\n          if (currentPathsValue === undefined) {\r\n            const currentModel = getModel(prevPathsValue);\r\n            if (currentModel) {\r\n              const subCoditions = await lookup([], value, currentModel.schema);\r\n              if (subCoditions) {\r\n                const ids = (\r\n                  await currentModel.find({ [paths]: subCoditions }, \"_id\")\r\n                ).map((v) => v._id);\r\n\r\n                return { $in: ids };\r\n              }\r\n            }\r\n          }\r\n\r\n        if (Array.isArray(value))\r\n          Object.assign(result, {\r\n            [paths]: await Promise.all(\r\n              value.map(\r\n                async (v) => await lookup(currentPathsArray, v, cSchema)\r\n              )\r\n            ),\r\n          });\r\n        else if (\r\n          typeof value === \"object\" &&\r\n          value !== null &&\r\n          Object.keys(value).length > 0\r\n        )\r\n          Object.assign(result, {\r\n            [paths]: Object.fromEntries(\r\n              await Promise.all(\r\n                Object.entries(value).map(\r\n                  async ([k, v]) =>\r\n                    Object.entries(\r\n                      await lookup(\r\n                        currentPathsArray,\r\n                        {\r\n                          [k]: v,\r\n                        },\r\n                        cSchema\r\n                      )\r\n                    )[0]\r\n                )\r\n              )\r\n            ),\r\n          });\r\n        else result[paths] = value;\r\n      }\r\n      return result;\r\n    }\r\n    (this as any)._conditions = await lookup([], (this as any)._conditions);\r\n    next();\r\n  });\r\n}\r\n"],"mappings":"8gBAAA,8CAEA,GAAM,GAAgC,CACpC,gBAAiB,CACf,QAAS,sEACT,QAAS,yCAEX,gBAAiB,CACf,QAAS,mHACT,QAAS,0DAOb,WAAc,EAAmB,CAhBjC,MAiBE,GAAI,IAAa,GAAU,CACzB,GAAM,GAAU,EAAS,GAEzB,MADc,YAAQ,IAAI,OAAZ,OAAoB,IAAI,MAAM,MAC3B,EAAQ,SACb,EAAQ,UAIjB,WAAiC,EAAgB,CAEtD,GAAI,EAAO,YAAY,OAAS,SAC9B,KAAM,IAAI,OAAM,EAAK,oBAGvB,EAAO,IAAI,CAAC,OAAQ,WAAY,eAAgB,EAAM,CAEpD,GAAM,GAAS,KAAK,MAAM,GAAG,OAG7B,GAAI,OAAO,KAAK,UAAU,IAAI,SAAW,EACvC,KAAM,IAAI,OAAM,EAAK,oBAGvB,GAAM,GAAiB,KAAK,MAAM,OAQlC,WAAkB,EAAyC,CAhD/D,MAiDM,GAAI,GAAS,GACb,GAAI,kBAAK,YAAa,WAAY,CAEhC,GAAM,GAAU,EAAI,QACpB,AAAI,qBAAS,MAAT,cAAc,SAAQ,GAAS,EAAQ,aAGjC,iBAAa,oBAEvB,MAAO,GAAU,EAAY,qBAE/B,MAAO,GAAO,GAShB,WACE,EACA,EAAkB,EACR,CAxEhB,MAyEM,GAAI,GAAyB,GAC7B,KAAO,EAAM,OAAS,GAAG,CACvB,GAAM,GAAO,KAAM,UAAN,OAAiB,GAC9B,GAAI,EAAQ,KAAK,CAAC,GAAG,EAAc,GAAM,KAAK,MAC5C,EAAa,KAAK,OACb,CACL,GAAM,GAAe,EAAS,EAAQ,KAAK,EAAa,KAAK,OAC7D,MAAI,GACa,CACb,EAAa,KAAK,KAClB,GAAG,EAAkB,CAAC,EAAM,GAAG,GAAQ,EAAa,SAG1C,CAAC,IAGnB,MAAO,GAWT,iBACE,EACA,EACA,EAAU,EACI,CAEd,GACE,MAAO,IAAe,UACtB,IAAe,MACf,OAAO,KAAK,GAAY,SAAW,EAEnC,MAAO,GAIT,GAAM,GAA8B,GAG9B,EAAiB,EAAQ,KAAK,EAAU,KAAK,MAEnD,OAAS,CAAC,EAAO,IAAU,QAAO,QAAQ,GAAa,CAIrD,GAAI,GAAO,KAAK,GACT,CACL,GAAM,GAAe,CACnB,GAAG,EAAkB,EAAM,MAAM,MACjC,GACA,YAAY,CAAC,EAAe,IAC5B,IAAiB,IACb,EACA,EAAG,GAAe,IAExB,CAAC,CAAC,EAAO,IAAU,OAAO,QAAQ,GAIpC,GAAM,GAAoB,EAAM,WAAW,KACvC,IAAU,IACR,EACA,GACF,CAAC,GAAG,EAAW,GAGb,EAAqB,EAAkB,KAAK,KAG5C,EAAoB,EAAQ,KAAK,GAEvC,GAAI,CAAC,EAAM,WAAW,MAChB,IAAsB,OAAW,CACnC,GAAM,GAAe,EAAS,GAC9B,GAAI,EAAc,CAChB,GAAM,GAAe,KAAM,GAAO,GAAI,EAAO,EAAa,QAC1D,GAAI,EAKF,MAAO,CAAE,IAHP,MAAM,GAAa,KAAK,EAAG,GAAQ,GAAgB,QACnD,IAAI,AAAC,GAAM,EAAE,OAOvB,AAAI,MAAM,QAAQ,GAChB,OAAO,OAAO,EAAQ,EACnB,GAAQ,KAAM,SAAQ,IACrB,EAAM,IACJ,KAAO,IAAM,KAAM,GAAO,EAAmB,EAAG,OAInD,AACH,MAAO,IAAU,UACjB,IAAU,MACV,OAAO,KAAK,GAAO,OAAS,EAE5B,OAAO,OAAO,EAAQ,EACnB,GAAQ,OAAO,YACd,KAAM,SAAQ,IACZ,OAAO,QAAQ,GAAO,IACpB,MAAO,CAAC,EAAG,KACT,OAAO,QACL,KAAM,GACJ,EACA,EACG,GAAI,GAEP,IAEF,QAKT,EAAO,GAAS,EAEvB,MAAO,GAET,AAAC,KAAa,YAAc,KAAM,GAAO,GAAK,KAAa,aAC3D","names":[]}